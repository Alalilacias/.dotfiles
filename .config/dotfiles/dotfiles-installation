#!/usr/bin/env bash
# Author: Alalilacias
# Description: Recopilation of the functions necesssary for the installation of the dotfiles
# Version: 0.3

# All custom install scripts must go in the same folder, as that is the way the installer is built.
# This is entirely due to my personal preference, but I believe that should be easier to manage than
# putting a distinct address (duplicated most of the time) in the config json files.
CUSTOM_CONFIG_DIR="${DOTCONFIG_DIR}/config"
CUSTOM_INSTALL_DIR="${DOTCONFIG_DIR}/scripts"
ENV_FILE="${CUSTOM_CONFIG_DIR}/environments.json"
PKG_FILE="${CUSTOM_CONFIG_DIR}/packages.json"
PKG_MANAGER_UPDATED=false
DATABASE_PARSER="jq"

check_databaseparser_availability() {
  if ! is_app_installed "executable" "$DATABASE_PARSER"; then
    log_warn "${DATABASE_PARSER} not available, installing..."

    local script_path="${CUSTOM_INSTALL_DIR}/${DATABASE_PARSER}"
    if [[ -f "$script_path" ]]; then
      source "$script_path"
    else
      log_error "Install script for ${DATABASE_PARSER} not found at ${script_path}"
      exit 1
    fi
  fi
}

# Checks if the given package installed, with some exceptions for special files that aren't installed through the manager.
# Currently only tested for apt, as I have no other machines.
is_app_installed() {
  local check_type="$1"
  local check_value="$2"

  # Always return false if FORCE is set
  if [[ "${FORCE:-false}" == "true" ]]; then
    return 1
  fi

  case "$check_type" in
  executable)
    command -v "$check_value" &>/dev/null
    ;;
  file)
    # Check common include paths
    find /usr/include /usr/local/include -name "$check_value" 2>/dev/null | grep -q .
    ;;
  python_module)
    python3 -c "import $check_value" &>/dev/null
    ;;
  npm_global_module)
    npm list -g --depth=0 "$check_value" &>/dev/null
    ;;
  *)
    log_warn "Unknown check_type '$check_type' with value '$check_value'. Assuming not installed."
    return 1
    ;;
  esac
}

install_all_environments() {
  for env in "${DEVENVS[@]}"; do
    install_environment "$env"
  done
}

install_environment() {
  local environment="$1"

  if [[ ! -f "$ENV_FILE" ]]; then
    log_error "Environment file not found: $ENV_FILE"
    return 1
  fi

  if ! jq -e --arg e "$environment" '.[$e]' "$ENV_FILE" >/dev/null; then
    log_warn "Environment '$environment' not defined in $ENV_FILE"
    return 1
  fi

  log_info "Installing environment: $environment"

  mapfile -t env_packages < <(jq -r --arg e "$environment" '.[$e][]' "$ENV_FILE")

  for package in "${env_packages[@]}"; do
    install_package "$package"
  done
}

install_package() {
  local package_name="$1"
  log_debug "Starting installation check for package: $package_name"

  if ! is_package_known "$package_name"; then
    log_error "Package '$package_name' not found in package database ($PKG_FILE)"
    return 1
  fi

  local check_type check_value
  check_type=$(get_pkg_field "$package_name" "check_type")
  check_value=$(get_pkg_field "$package_name" "check_value")

  if is_app_installed "$check_type" "$check_value"; then
    log_debug "Package '$package_name' already installed"
    return 0
  fi

  log_info "Installing package: $package_name"

  # Recursively install dependencies
  local dependencies
  dependencies=$(get_pkg_field "$package_name" "dependencies" | jq -r '.[]')
  for dep in $dependencies; do
    log_debug "Starting installation check for dependency: $dep"
    install_package "$dep"
  done

  if is_pkg_available_through_pm "$package_name"; then
    update_pm_if_needed
    echo "Package $package_name is available_through_pm"
  else
    echo "Package $package_name is not available_through_pm"
  fi

  #  log_info "Successfully installed: $package_name"
}

is_package_known() {
  local name="$1"
  jq -e --arg pkg "$name" '.packages[$pkg]' "$PKG_FILE" >/dev/null
}
get_pkg_field() {
  local name="$1" field="$2"
  jq -r --arg pkg "$name" --arg field "$field" '.packages[$pkg][$field]' "$PKG_FILE"
}
is_pkg_available_through_pm() {
  local name="$1"
  jq -e --arg pkg "$name" '.packages[$pkg].available_through_pm == true' "$PKG_FILE" >/dev/null
}

# Makeshift function. Should be modified if Dotfiles are modified to accomodate other package managers.
update_pm_if_needed() {
  if [[ "$PKG_MANAGER_UPDATED" == "false" ]]; then
    case "$PACKAGE_MANAGER" in
    apt)
      sudo apt update
      ;;
    *)
      echo "Unknown package manager: $PACKAGE_MANAGER"
      ;;
    esac
    PKG_MANAGER_UPDATED=true
  fi
}
