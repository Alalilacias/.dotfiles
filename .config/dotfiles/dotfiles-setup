#!/usr/bin/env bash
# Author: Alalilacias
# Description: Functions and variables for the setup of the dotfiles installation.
# Version: 0.1

# Global variables.
CLEANED_ARGS=()
DEVENVS=()  # Environments are sets of programs, so they can be mixed and matched.
FORCE=false # Ignore if the program is installed and proceed to installation request to pm.
LOG_LEVEL="INFO"

# Main functions.
#
# Logger for this script. Thanks to [GingerGraham](https://github.com/GingerGraham).
# His script is something I was considering making myself, but his work saved me the time
# and the structure of his code has helped shape this install script itself.
start_logger() {
  source "${HOME}/.dotfiles/.config/dotfiles/utils/bash_logging/logging.sh"
  # LOG_LEVEL will be set to the default if not specified.
  init_logger --color --journal --tag "dotfiles-install" --level "$LOG_LEVEL"
}

# Helper functions.
#
# Check if there's any dev argument
check_dev_present() {
  local -a args=("$@")
  for ((i = 0; i < ${#args[@]}; i++)); do
    case "${args[i]}" in
    -d | --devenv)
      if [[ -z "${args[i + 1]}" || "${args[i + 1]}" == -* ]]; then
        log_error "Missing or invalid value for --devenv. You must pass a comma-separated list (e.g., -d base,cpp)"
        exit 1
      fi
      return 0
      ;;
    esac
  done

  log_error "Missing required argument: --devenv <env1,env2,...>"
  exit 1
}
# Parse log level manually and previously to the rest of the opts as the logger is needed for the rest of the script.
extract_log_level() {
  local args=()
  local valid_levels=("DEBUG" "INFO" "NOTICE" "WARN" "ERROR" "CRITICAL" "ALERT" "EMERGENCY")
  local found_level=""
  local arg value

  if [[ $# -eq 0 ]]; then
    echo "No arguments provided. Some arguments are necessary for installation. Use -h|--help to obtain more information."
    exit 1
  fi

  while [[ $# -gt 0 ]]; do
    arg="$1"
    value="$2"

    case "$arg" in
    -l | --log-level)
      if [[ -n "$value" && "$value" != -* ]]; then
        for level in "${valid_levels[@]}"; do
          if [[ "$value" == "$level" ]]; then
            found_level="$value"
            break
          fi
        done

        if [[ -n "$found_level" ]]; then
          LOG_LEVEL="$found_level"
        else
          echo "Invalid log level: '$value'. Defaulting to INFO."
        fi
        shift 2
      else
        echo "Missing log level value after $arg. Defaulting to INFO."
        shift
      fi
      ;;
    *)
      args+=("$arg")
      shift
      ;;
    esac
  done

  CLEANED_ARGS=("${args[@]}")
}
# Argument parsing.
readopts() {
  TEMP=$(getopt -o d:hf --long devenv:,help,force -n "$0" -- "$@")

  eval set -- "$TEMP"

  while true; do
    case "$1" in
    -d | --devenv)
      IFS=',' read -ra ENV_ARRAY <<<"$2"
      DEVENVS+=("${ENV_ARRAY[@]}")
      shift 2
      ;;
    -f | --force)
      FORCE=true
      shift
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *)
      log_error "Invalid option $1"
      shift
      ;;
    esac
  done
}
# Extract the package manager from the system. This is to facilitat installation and because
# many programs will depend on being installed through their pm.
extract_pm() {
  if command -v apt >/dev/null 2>&1; then
    echo "apt" # Debian-based
  else
    log_error "Package manager not supported, skipping installation of packages no supported outside of them."
  fi
}
